; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -S -passes=expand-memcmp -mcpu=pwr8 -mtriple=powerpc64le-unknown-gnu-linux < %s | FileCheck %s
target datalayout = "e-m:e-i64:64-n32:64"
target triple = "powerpc64le-unknown-linux-gnu"

@zeroEqualityTest01.buffer1 = private unnamed_addr constant [3 x i32] [i32 1, i32 2, i32 4], align 4
@zeroEqualityTest01.buffer2 = private unnamed_addr constant [3 x i32] [i32 1, i32 2, i32 3], align 4
@zeroEqualityTest02.buffer1 = private unnamed_addr constant [4 x i32] [i32 4, i32 0, i32 0, i32 0], align 4
@zeroEqualityTest02.buffer2 = private unnamed_addr constant [4 x i32] [i32 3, i32 0, i32 0, i32 0], align 4
@zeroEqualityTest03.buffer1 = private unnamed_addr constant [4 x i32] [i32 0, i32 0, i32 0, i32 3], align 4
@zeroEqualityTest03.buffer2 = private unnamed_addr constant [4 x i32] [i32 0, i32 0, i32 0, i32 4], align 4
@zeroEqualityTest04.buffer1 = private unnamed_addr constant [15 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14], align 4
@zeroEqualityTest04.buffer2 = private unnamed_addr constant [15 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 13], align 4

declare signext i32 @memcmp(ptr nocapture, ptr nocapture, i64) local_unnamed_addr #1

; Check 4 bytes - requires 1 load for each param.
define signext i32 @zeroEqualityTest02(ptr %x, ptr %y) {
; CHECK-LABEL: define signext i32 @zeroEqualityTest02(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[X]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[Y]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    [[DOT:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    ret i32 [[DOT]]
;
  %call = tail call signext i32 @memcmp(ptr %x, ptr %y, i64 4)
  %not.cmp = icmp ne i32 %call, 0
  %. = zext i1 %not.cmp to i32
  ret i32 %.
}

; Check 16 bytes - requires 2 loads for each param (or use vectors?).
define signext i32 @zeroEqualityTest01(ptr %x, ptr %y) {
; CHECK-LABEL: define signext i32 @zeroEqualityTest01(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[X]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[Y]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    br i1 [[TMP3]], label [[RES_BLOCK:%.*]], label [[LOADBB1:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[X]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[Y]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = icmp ne i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    br i1 [[TMP8]], label [[RES_BLOCK]], label [[ENDBLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ 1, [[RES_BLOCK]] ]
; CHECK-NEXT:    [[NOT_TOBOOL:%.*]] = icmp ne i32 [[PHI_RES]], 0
; CHECK-NEXT:    [[DOT:%.*]] = zext i1 [[NOT_TOBOOL]] to i32
; CHECK-NEXT:    ret i32 [[DOT]]
;
  %call = tail call signext i32 @memcmp(ptr %x, ptr %y, i64 16)
  %not.tobool = icmp ne i32 %call, 0
  %. = zext i1 %not.tobool to i32
  ret i32 %.
}

; Check 7 bytes - requires 3 loads for each param.
define signext i32 @zeroEqualityTest03(ptr %x, ptr %y) {
; CHECK-LABEL: define signext i32 @zeroEqualityTest03(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[X]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[Y]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    br i1 [[TMP3]], label [[RES_BLOCK:%.*]], label [[LOADBB1:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[X]], i64 4
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[Y]], i64 4
; CHECK-NEXT:    [[TMP6:%.*]] = load i16, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i16, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = icmp ne i16 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    br i1 [[TMP8]], label [[RES_BLOCK]], label [[LOADBB2:%.*]]
; CHECK:       loadbb2:
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[X]], i64 6
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[Y]], i64 6
; CHECK-NEXT:    [[TMP11:%.*]] = load i8, ptr [[TMP9]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i8, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP13:%.*]] = icmp ne i8 [[TMP11]], [[TMP12]]
; CHECK-NEXT:    br i1 [[TMP13]], label [[RES_BLOCK]], label [[ENDBLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB2]] ], [ 1, [[RES_BLOCK]] ]
; CHECK-NEXT:    [[NOT_LNOT:%.*]] = icmp ne i32 [[PHI_RES]], 0
; CHECK-NEXT:    [[COND:%.*]] = zext i1 [[NOT_LNOT]] to i32
; CHECK-NEXT:    ret i32 [[COND]]
;
  %call = tail call signext i32 @memcmp(ptr %x, ptr %y, i64 7)
  %not.lnot = icmp ne i32 %call, 0
  %cond = zext i1 %not.lnot to i32
  ret i32 %cond
}

; Validate with > 0
define signext i32 @zeroEqualityTest04() {
; CHECK-LABEL: define signext i32 @zeroEqualityTest04(
; CHECK-SAME: ) #[[ATTR0]] {
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i64 [ 288230376151711744, [[LOADBB]] ], [ 0, [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i64 [ 216172782113783808, [[LOADBB]] ], [ 0, [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    br i1 false, label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    br i1 true, label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    [[NOT_CMP:%.*]] = icmp slt i32 [[PHI_RES]], 1
; CHECK-NEXT:    [[DOT:%.*]] = zext i1 [[NOT_CMP]] to i32
; CHECK-NEXT:    ret i32 [[DOT]]
;
  %call = tail call signext i32 @memcmp(ptr @zeroEqualityTest02.buffer1, ptr @zeroEqualityTest02.buffer2, i64 16)
  %not.cmp = icmp slt i32 %call, 1
  %. = zext i1 %not.cmp to i32
  ret i32 %.
}

; Validate with < 0
define signext i32 @zeroEqualityTest05() {
; CHECK-LABEL: define signext i32 @zeroEqualityTest05(
; CHECK-SAME: ) #[[ATTR0]] {
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i64 [ 0, [[LOADBB]] ], [ 50331648, [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i64 [ 0, [[LOADBB]] ], [ 67108864, [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    br i1 true, label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    br i1 false, label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    [[CALL_LOBIT:%.*]] = lshr i32 [[PHI_RES]], 31
; CHECK-NEXT:    [[CALL_LOBIT_NOT:%.*]] = xor i32 [[CALL_LOBIT]], 1
; CHECK-NEXT:    ret i32 [[CALL_LOBIT_NOT]]
;
  %call = tail call signext i32 @memcmp(ptr @zeroEqualityTest03.buffer1, ptr @zeroEqualityTest03.buffer2, i64 16)
  %call.lobit = lshr i32 %call, 31
  %call.lobit.not = xor i32 %call.lobit, 1
  ret i32 %call.lobit.not
}

; Validate with memcmp()?:
define signext i32 @equalityFoldTwoConstants() {
; CHECK-LABEL: define signext i32 @equalityFoldTwoConstants(
; CHECK-SAME: ) #[[ATTR0]] {
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    br i1 false, label [[RES_BLOCK:%.*]], label [[LOADBB1:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    br i1 false, label [[RES_BLOCK]], label [[ENDBLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ 1, [[RES_BLOCK]] ]
; CHECK-NEXT:    [[NOT_TOBOOL:%.*]] = icmp eq i32 [[PHI_RES]], 0
; CHECK-NEXT:    [[COND:%.*]] = zext i1 [[NOT_TOBOOL]] to i32
; CHECK-NEXT:    ret i32 [[COND]]
;
  %call = tail call signext i32 @memcmp(ptr @zeroEqualityTest04.buffer1, ptr @zeroEqualityTest04.buffer2, i64 16)
  %not.tobool = icmp eq i32 %call, 0
  %cond = zext i1 %not.tobool to i32
  ret i32 %cond
}

define signext i32 @equalityFoldOneConstant(ptr %X) {
; CHECK-LABEL: define signext i32 @equalityFoldOneConstant(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[X]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i64 4294967296, [[TMP1]]
; CHECK-NEXT:    br i1 [[TMP2]], label [[RES_BLOCK:%.*]], label [[LOADBB1:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[X]], i64 8
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, ptr [[TMP3]], align 1
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i64 12884901890, [[TMP4]]
; CHECK-NEXT:    br i1 [[TMP5]], label [[RES_BLOCK]], label [[ENDBLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ 1, [[RES_BLOCK]] ]
; CHECK-NEXT:    [[NOT_TOBOOL:%.*]] = icmp eq i32 [[PHI_RES]], 0
; CHECK-NEXT:    [[COND:%.*]] = zext i1 [[NOT_TOBOOL]] to i32
; CHECK-NEXT:    ret i32 [[COND]]
;
  %call = tail call signext i32 @memcmp(ptr @zeroEqualityTest04.buffer1, ptr %X, i64 16)
  %not.tobool = icmp eq i32 %call, 0
  %cond = zext i1 %not.tobool to i32
  ret i32 %cond
}

define i1 @length2_eq_nobuiltin_attr(ptr %X, ptr %Y) nounwind {
; CHECK-LABEL: define i1 @length2_eq_nobuiltin_attr(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    [[M:%.*]] = tail call signext i32 @memcmp(ptr [[X]], ptr [[Y]], i64 2) #[[ATTR3:[0-9]+]]
; CHECK-NEXT:    [[C:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    ret i1 [[C]]
;
  %m = tail call signext i32 @memcmp(ptr %X, ptr %Y, i64 2) nobuiltin
  %c = icmp eq i32 %m, 0
  ret i1 %c
}

