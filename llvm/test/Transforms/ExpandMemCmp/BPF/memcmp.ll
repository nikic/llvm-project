; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -S -passes=expand-memcmp -mtriple=bpf < %s | FileCheck %s --check-prefix=BPF
; RUN: opt -S -passes=expand-memcmp -mtriple=bpf -mcpu=v3 < %s | FileCheck %s --check-prefix=BPF-V3
;
; Source code:
;   /* set aligned 4 to minimize the number of loads */
;   struct build_id {
;     unsigned char id[20];
;   } __attribute__((aligned(4)));
;
;   /* try to compute a local build_id */
;   void bar1(ptr);
;
;   /* the global build_id to compare */
;   struct build_id id2;
;
;   int foo()
;   {
;     struct build_id id1;
;
;     bar1(&id1);
;     return __builtin_memcmp(&id1, &id2, sizeof(id1)) == 0;
;   }
; Compilation flags:
;   clang -target bpf -S -O2 t.c -emit-llvm

%struct.build_id = type { [20 x i8] }

@id2 = dso_local global %struct.build_id zeroinitializer, align 4

; Function Attrs: noinline nounwind
define dso_local i32 @foo() #0 {
; BPF-LABEL: define dso_local i32 @foo(
; BPF-SAME: ) #[[ATTR0:[0-9]+]] {
; BPF-NEXT:  entry:
; BPF-NEXT:    [[ID1:%.*]] = alloca [[STRUCT_BUILD_ID:%.*]], align 4
; BPF-NEXT:    call void @bar1(ptr noundef [[ID1]])
; BPF-NEXT:    br label [[LOADBB:%.*]]
; BPF:       res_block:
; BPF-NEXT:    br label [[ENDBLOCK:%.*]]
; BPF:       loadbb:
; BPF-NEXT:    [[TMP0:%.*]] = load i64, ptr [[ID1]], align 4
; BPF-NEXT:    [[TMP1:%.*]] = load i64, ptr @id2, align 4
; BPF-NEXT:    [[TMP2:%.*]] = icmp ne i64 [[TMP0]], [[TMP1]]
; BPF-NEXT:    br i1 [[TMP2]], label [[RES_BLOCK:%.*]], label [[LOADBB1:%.*]]
; BPF:       loadbb1:
; BPF-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[ID1]], i64 8
; BPF-NEXT:    [[TMP4:%.*]] = load i64, ptr [[TMP3]], align 4
; BPF-NEXT:    [[TMP5:%.*]] = load i64, ptr getelementptr (i8, ptr @id2, i64 8), align 4
; BPF-NEXT:    [[TMP6:%.*]] = icmp ne i64 [[TMP4]], [[TMP5]]
; BPF-NEXT:    br i1 [[TMP6]], label [[RES_BLOCK]], label [[LOADBB2:%.*]]
; BPF:       loadbb2:
; BPF-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[ID1]], i64 16
; BPF-NEXT:    [[TMP8:%.*]] = load i32, ptr [[TMP7]], align 4
; BPF-NEXT:    [[TMP9:%.*]] = load i32, ptr getelementptr (i8, ptr @id2, i64 16), align 4
; BPF-NEXT:    [[TMP10:%.*]] = icmp ne i32 [[TMP8]], [[TMP9]]
; BPF-NEXT:    br i1 [[TMP10]], label [[RES_BLOCK]], label [[ENDBLOCK]]
; BPF:       endblock:
; BPF-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB2]] ], [ 1, [[RES_BLOCK]] ]
; BPF-NEXT:    [[CMP:%.*]] = icmp eq i32 [[PHI_RES]], 0
; BPF-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; BPF-NEXT:    ret i32 [[CONV]]
;
; BPF-V3-LABEL: define dso_local i32 @foo(
; BPF-V3-SAME: ) #[[ATTR0:[0-9]+]] {
; BPF-V3-NEXT:  entry:
; BPF-V3-NEXT:    [[ID1:%.*]] = alloca [[STRUCT_BUILD_ID:%.*]], align 4
; BPF-V3-NEXT:    call void @bar1(ptr noundef [[ID1]])
; BPF-V3-NEXT:    br label [[LOADBB:%.*]]
; BPF-V3:       res_block:
; BPF-V3-NEXT:    br label [[ENDBLOCK:%.*]]
; BPF-V3:       loadbb:
; BPF-V3-NEXT:    [[TMP0:%.*]] = load i64, ptr [[ID1]], align 4
; BPF-V3-NEXT:    [[TMP1:%.*]] = load i64, ptr @id2, align 4
; BPF-V3-NEXT:    [[TMP2:%.*]] = icmp ne i64 [[TMP0]], [[TMP1]]
; BPF-V3-NEXT:    br i1 [[TMP2]], label [[RES_BLOCK:%.*]], label [[LOADBB1:%.*]]
; BPF-V3:       loadbb1:
; BPF-V3-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[ID1]], i64 8
; BPF-V3-NEXT:    [[TMP4:%.*]] = load i64, ptr [[TMP3]], align 4
; BPF-V3-NEXT:    [[TMP5:%.*]] = load i64, ptr getelementptr (i8, ptr @id2, i64 8), align 4
; BPF-V3-NEXT:    [[TMP6:%.*]] = icmp ne i64 [[TMP4]], [[TMP5]]
; BPF-V3-NEXT:    br i1 [[TMP6]], label [[RES_BLOCK]], label [[LOADBB2:%.*]]
; BPF-V3:       loadbb2:
; BPF-V3-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[ID1]], i64 16
; BPF-V3-NEXT:    [[TMP8:%.*]] = load i32, ptr [[TMP7]], align 4
; BPF-V3-NEXT:    [[TMP9:%.*]] = load i32, ptr getelementptr (i8, ptr @id2, i64 16), align 4
; BPF-V3-NEXT:    [[TMP10:%.*]] = icmp ne i32 [[TMP8]], [[TMP9]]
; BPF-V3-NEXT:    br i1 [[TMP10]], label [[RES_BLOCK]], label [[ENDBLOCK]]
; BPF-V3:       endblock:
; BPF-V3-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB2]] ], [ 1, [[RES_BLOCK]] ]
; BPF-V3-NEXT:    [[CMP:%.*]] = icmp eq i32 [[PHI_RES]], 0
; BPF-V3-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; BPF-V3-NEXT:    ret i32 [[CONV]]
;
entry:
  %id1 = alloca %struct.build_id, align 4
  call void @bar1(ptr noundef %id1)
  %call = call i32 @memcmp(ptr noundef %id1, ptr noundef @id2, i64 noundef 20) #3
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare dso_local void @bar1(ptr noundef) #1

; Function Attrs: nounwind
declare dso_local i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #2

attributes #0 = { noinline nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #2 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"frame-pointer", i32 2}
!2 = !{!"clang version 18.0.0git (git@github.com:llvm/llvm-project.git a776740d6296520b8bde156aa3f8d9ecb32cddd9)"}
