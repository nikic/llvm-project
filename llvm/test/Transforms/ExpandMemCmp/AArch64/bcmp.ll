; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -S -passes=expand-memcmp  < %s -mtriple=aarch64-unknown-unknown | FileCheck %s

declare i32 @bcmp(ptr, ptr, i64)

define i1 @bcmp0(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp0(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    ret i1 true
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 0)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp1(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp1(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i8 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP4]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 1)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp2(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp2(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i16, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i16, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i16 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP4]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 2)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

; or (and (xor a, b), C1), (and (xor c, d), C2)
define i1 @bcmp3(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp3(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i16, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i16, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i16 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 2
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 2
; CHECK-NEXT:    [[TMP6:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i8, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = zext i8 [[TMP6]] to i16
; CHECK-NEXT:    [[TMP9:%.*]] = zext i8 [[TMP7]] to i16
; CHECK-NEXT:    [[TMP10:%.*]] = xor i16 [[TMP8]], [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = or i16 [[TMP3]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ne i16 [[TMP11]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = zext i1 [[TMP12]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 3)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp4(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp4(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP4]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 4)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

; or (xor a, b), (and (xor c, d), C2)
define i1 @bcmp5(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp5(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 4
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 4
; CHECK-NEXT:    [[TMP6:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i8, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = zext i8 [[TMP6]] to i32
; CHECK-NEXT:    [[TMP9:%.*]] = zext i8 [[TMP7]] to i32
; CHECK-NEXT:    [[TMP10:%.*]] = xor i32 [[TMP8]], [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = or i32 [[TMP3]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ne i32 [[TMP11]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = zext i1 [[TMP12]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 5)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

; or (xor a, b), (and (xor c, d), C2)
define i1 @bcmp6(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp6(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 4
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 4
; CHECK-NEXT:    [[TMP6:%.*]] = load i16, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i16, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = zext i16 [[TMP6]] to i32
; CHECK-NEXT:    [[TMP9:%.*]] = zext i16 [[TMP7]] to i32
; CHECK-NEXT:    [[TMP10:%.*]] = xor i32 [[TMP8]], [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = or i32 [[TMP3]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ne i32 [[TMP11]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = zext i1 [[TMP12]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 6)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

; or (xor a, b), (xor c, d)
define i1 @bcmp7(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp7(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 3
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 3
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i32 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = or i32 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = icmp ne i32 [[TMP9]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = zext i1 [[TMP10]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP11]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 7)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp8(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp8(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP4]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 8)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

; or (xor a, b), (and (xor c, d), C2)
define i1 @bcmp9(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp9(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i8, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = zext i8 [[TMP6]] to i64
; CHECK-NEXT:    [[TMP9:%.*]] = zext i8 [[TMP7]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = xor i64 [[TMP8]], [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = or i64 [[TMP3]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ne i64 [[TMP11]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = zext i1 [[TMP12]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 9)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp10(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp10(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i16, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i16, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = zext i16 [[TMP6]] to i64
; CHECK-NEXT:    [[TMP9:%.*]] = zext i16 [[TMP7]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = xor i64 [[TMP8]], [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = or i64 [[TMP3]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ne i64 [[TMP11]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = zext i1 [[TMP12]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 10)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp11(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp11(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 3
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 3
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = icmp ne i64 [[TMP9]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = zext i1 [[TMP10]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP11]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 11)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp12(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp12(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = zext i32 [[TMP6]] to i64
; CHECK-NEXT:    [[TMP9:%.*]] = zext i32 [[TMP7]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = xor i64 [[TMP8]], [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = or i64 [[TMP3]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ne i64 [[TMP11]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = zext i1 [[TMP12]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 12)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp13(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp13(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 5
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 5
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = icmp ne i64 [[TMP9]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = zext i1 [[TMP10]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP11]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 13)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp14(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp14(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 6
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 6
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = icmp ne i64 [[TMP9]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = zext i1 [[TMP10]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP11]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 14)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp15(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp15(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 7
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 7
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = icmp ne i64 [[TMP9]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = zext i1 [[TMP10]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP11]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 15)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp16(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp16(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = icmp ne i64 [[TMP9]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = zext i1 [[TMP10]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP11]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 16)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp20(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp20(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[A]], i64 16
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[B]], i64 16
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP9]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP13:%.*]] = zext i32 [[TMP11]] to i64
; CHECK-NEXT:    [[TMP14:%.*]] = zext i32 [[TMP12]] to i64
; CHECK-NEXT:    [[TMP15:%.*]] = xor i64 [[TMP13]], [[TMP14]]
; CHECK-NEXT:    [[TMP16:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP17:%.*]] = or i64 [[TMP16]], [[TMP15]]
; CHECK-NEXT:    [[TMP18:%.*]] = icmp ne i64 [[TMP17]], 0
; CHECK-NEXT:    [[TMP19:%.*]] = zext i1 [[TMP18]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP19]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 20)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp24(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp24(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[A]], i64 16
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[B]], i64 16
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, ptr [[TMP9]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i64, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP11]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP15:%.*]] = or i64 [[TMP14]], [[TMP13]]
; CHECK-NEXT:    [[TMP16:%.*]] = icmp ne i64 [[TMP15]], 0
; CHECK-NEXT:    [[TMP17:%.*]] = zext i1 [[TMP16]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP17]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 24)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp28(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp28(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[A]], i64 16
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[B]], i64 16
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, ptr [[TMP9]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i64, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP11]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr i8, ptr [[A]], i64 24
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr i8, ptr [[B]], i64 24
; CHECK-NEXT:    [[TMP16:%.*]] = load i32, ptr [[TMP14]], align 1
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[TMP15]], align 1
; CHECK-NEXT:    [[TMP18:%.*]] = zext i32 [[TMP16]] to i64
; CHECK-NEXT:    [[TMP19:%.*]] = zext i32 [[TMP17]] to i64
; CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP18]], [[TMP19]]
; CHECK-NEXT:    [[TMP21:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP22:%.*]] = or i64 [[TMP13]], [[TMP20]]
; CHECK-NEXT:    [[TMP23:%.*]] = or i64 [[TMP21]], [[TMP22]]
; CHECK-NEXT:    [[TMP24:%.*]] = icmp ne i64 [[TMP23]], 0
; CHECK-NEXT:    [[TMP25:%.*]] = zext i1 [[TMP24]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP25]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 28)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp33(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp33(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[A]], i64 16
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[B]], i64 16
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, ptr [[TMP9]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i64, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP11]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr i8, ptr [[A]], i64 24
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr i8, ptr [[B]], i64 24
; CHECK-NEXT:    [[TMP16:%.*]] = load i64, ptr [[TMP14]], align 1
; CHECK-NEXT:    [[TMP17:%.*]] = load i64, ptr [[TMP15]], align 1
; CHECK-NEXT:    [[TMP18:%.*]] = xor i64 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr i8, ptr [[A]], i64 32
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr i8, ptr [[B]], i64 32
; CHECK-NEXT:    [[TMP21:%.*]] = load i8, ptr [[TMP19]], align 1
; CHECK-NEXT:    [[TMP22:%.*]] = load i8, ptr [[TMP20]], align 1
; CHECK-NEXT:    [[TMP23:%.*]] = zext i8 [[TMP21]] to i64
; CHECK-NEXT:    [[TMP24:%.*]] = zext i8 [[TMP22]] to i64
; CHECK-NEXT:    [[TMP25:%.*]] = xor i64 [[TMP23]], [[TMP24]]
; CHECK-NEXT:    [[TMP26:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP27:%.*]] = or i64 [[TMP13]], [[TMP18]]
; CHECK-NEXT:    [[TMP28:%.*]] = or i64 [[TMP26]], [[TMP27]]
; CHECK-NEXT:    [[TMP29:%.*]] = or i64 [[TMP28]], [[TMP25]]
; CHECK-NEXT:    [[TMP30:%.*]] = icmp ne i64 [[TMP29]], 0
; CHECK-NEXT:    [[TMP31:%.*]] = zext i1 [[TMP30]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP31]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 33)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp38(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp38(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[A]], i64 16
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[B]], i64 16
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, ptr [[TMP9]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i64, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP11]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr i8, ptr [[A]], i64 24
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr i8, ptr [[B]], i64 24
; CHECK-NEXT:    [[TMP16:%.*]] = load i64, ptr [[TMP14]], align 1
; CHECK-NEXT:    [[TMP17:%.*]] = load i64, ptr [[TMP15]], align 1
; CHECK-NEXT:    [[TMP18:%.*]] = xor i64 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr i8, ptr [[A]], i64 30
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr i8, ptr [[B]], i64 30
; CHECK-NEXT:    [[TMP21:%.*]] = load i64, ptr [[TMP19]], align 1
; CHECK-NEXT:    [[TMP22:%.*]] = load i64, ptr [[TMP20]], align 1
; CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP21]], [[TMP22]]
; CHECK-NEXT:    [[TMP24:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP25:%.*]] = or i64 [[TMP13]], [[TMP18]]
; CHECK-NEXT:    [[TMP26:%.*]] = or i64 [[TMP24]], [[TMP25]]
; CHECK-NEXT:    [[TMP27:%.*]] = or i64 [[TMP26]], [[TMP23]]
; CHECK-NEXT:    [[TMP28:%.*]] = icmp ne i64 [[TMP27]], 0
; CHECK-NEXT:    [[TMP29:%.*]] = zext i1 [[TMP28]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP29]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 38)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp45(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp45(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[A]], i64 16
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[B]], i64 16
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, ptr [[TMP9]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i64, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP11]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr i8, ptr [[A]], i64 24
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr i8, ptr [[B]], i64 24
; CHECK-NEXT:    [[TMP16:%.*]] = load i64, ptr [[TMP14]], align 1
; CHECK-NEXT:    [[TMP17:%.*]] = load i64, ptr [[TMP15]], align 1
; CHECK-NEXT:    [[TMP18:%.*]] = xor i64 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr i8, ptr [[A]], i64 32
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr i8, ptr [[B]], i64 32
; CHECK-NEXT:    [[TMP21:%.*]] = load i64, ptr [[TMP19]], align 1
; CHECK-NEXT:    [[TMP22:%.*]] = load i64, ptr [[TMP20]], align 1
; CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP21]], [[TMP22]]
; CHECK-NEXT:    [[TMP24:%.*]] = getelementptr i8, ptr [[A]], i64 37
; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr i8, ptr [[B]], i64 37
; CHECK-NEXT:    [[TMP26:%.*]] = load i64, ptr [[TMP24]], align 1
; CHECK-NEXT:    [[TMP27:%.*]] = load i64, ptr [[TMP25]], align 1
; CHECK-NEXT:    [[TMP28:%.*]] = xor i64 [[TMP26]], [[TMP27]]
; CHECK-NEXT:    [[TMP29:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP30:%.*]] = or i64 [[TMP13]], [[TMP18]]
; CHECK-NEXT:    [[TMP31:%.*]] = or i64 [[TMP23]], [[TMP28]]
; CHECK-NEXT:    [[TMP32:%.*]] = or i64 [[TMP29]], [[TMP30]]
; CHECK-NEXT:    [[TMP33:%.*]] = or i64 [[TMP32]], [[TMP31]]
; CHECK-NEXT:    [[TMP34:%.*]] = icmp ne i64 [[TMP33]], 0
; CHECK-NEXT:    [[TMP35:%.*]] = zext i1 [[TMP34]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP35]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 45)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

; Although the large cmp chain may be not profitable on high end CPU, we
; believe it is better on most cpus, so perform the transform now.
; 8 xor + 7 or + 1 cmp only need 6 cycles on a 4 width ALU port machine
;   2 cycle for xor
;   3 cycle for or
;   1 cycle for cmp
define i1 @bcmp64(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp64(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = xor i64 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[A]], i64 16
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[B]], i64 16
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, ptr [[TMP9]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i64, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP11]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr i8, ptr [[A]], i64 24
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr i8, ptr [[B]], i64 24
; CHECK-NEXT:    [[TMP16:%.*]] = load i64, ptr [[TMP14]], align 1
; CHECK-NEXT:    [[TMP17:%.*]] = load i64, ptr [[TMP15]], align 1
; CHECK-NEXT:    [[TMP18:%.*]] = xor i64 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr i8, ptr [[A]], i64 32
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr i8, ptr [[B]], i64 32
; CHECK-NEXT:    [[TMP21:%.*]] = load i64, ptr [[TMP19]], align 1
; CHECK-NEXT:    [[TMP22:%.*]] = load i64, ptr [[TMP20]], align 1
; CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP21]], [[TMP22]]
; CHECK-NEXT:    [[TMP24:%.*]] = getelementptr i8, ptr [[A]], i64 40
; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr i8, ptr [[B]], i64 40
; CHECK-NEXT:    [[TMP26:%.*]] = load i64, ptr [[TMP24]], align 1
; CHECK-NEXT:    [[TMP27:%.*]] = load i64, ptr [[TMP25]], align 1
; CHECK-NEXT:    [[TMP28:%.*]] = xor i64 [[TMP26]], [[TMP27]]
; CHECK-NEXT:    [[TMP29:%.*]] = getelementptr i8, ptr [[A]], i64 48
; CHECK-NEXT:    [[TMP30:%.*]] = getelementptr i8, ptr [[B]], i64 48
; CHECK-NEXT:    [[TMP31:%.*]] = load i64, ptr [[TMP29]], align 1
; CHECK-NEXT:    [[TMP32:%.*]] = load i64, ptr [[TMP30]], align 1
; CHECK-NEXT:    [[TMP33:%.*]] = xor i64 [[TMP31]], [[TMP32]]
; CHECK-NEXT:    [[TMP34:%.*]] = getelementptr i8, ptr [[A]], i64 56
; CHECK-NEXT:    [[TMP35:%.*]] = getelementptr i8, ptr [[B]], i64 56
; CHECK-NEXT:    [[TMP36:%.*]] = load i64, ptr [[TMP34]], align 1
; CHECK-NEXT:    [[TMP37:%.*]] = load i64, ptr [[TMP35]], align 1
; CHECK-NEXT:    [[TMP38:%.*]] = xor i64 [[TMP36]], [[TMP37]]
; CHECK-NEXT:    [[TMP39:%.*]] = or i64 [[TMP3]], [[TMP8]]
; CHECK-NEXT:    [[TMP40:%.*]] = or i64 [[TMP13]], [[TMP18]]
; CHECK-NEXT:    [[TMP41:%.*]] = or i64 [[TMP23]], [[TMP28]]
; CHECK-NEXT:    [[TMP42:%.*]] = or i64 [[TMP33]], [[TMP38]]
; CHECK-NEXT:    [[TMP43:%.*]] = or i64 [[TMP39]], [[TMP40]]
; CHECK-NEXT:    [[TMP44:%.*]] = or i64 [[TMP41]], [[TMP42]]
; CHECK-NEXT:    [[TMP45:%.*]] = or i64 [[TMP43]], [[TMP44]]
; CHECK-NEXT:    [[TMP46:%.*]] = icmp ne i64 [[TMP45]], 0
; CHECK-NEXT:    [[TMP47:%.*]] = zext i1 [[TMP46]] to i32
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[TMP47]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 64)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp89(ptr %a, ptr %b) {
; CHECK-LABEL: define i1 @bcmp89(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    [[CR:%.*]] = call i32 @bcmp(ptr [[A]], ptr [[B]], i64 89)
; CHECK-NEXT:    [[R:%.*]] = icmp eq i32 [[CR]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %cr = call i32 @bcmp(ptr %a, ptr %b, i64 89)
  %r = icmp eq i32 %cr, 0
  ret i1 %r
}

define i1 @bcmp_zext(i32 %0, i32 %1, i8 %2, i8 %3) {
; CHECK-LABEL: define i1 @bcmp_zext(
; CHECK-SAME: i32 [[TMP0:%.*]], i32 [[TMP1:%.*]], i8 [[TMP2:%.*]], i8 [[TMP3:%.*]]) {
; CHECK-NEXT:    [[TMP5:%.*]] = xor i32 [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP6:%.*]] = xor i8 [[TMP3]], [[TMP2]]
; CHECK-NEXT:    [[TMP7:%.*]] = zext i8 [[TMP6]] to i32
; CHECK-NEXT:    [[TMP8:%.*]] = or i32 [[TMP5]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i32 [[TMP8]], 0
; CHECK-NEXT:    ret i1 [[TMP9]]
;
  %5 = xor i32 %1, %0
  %6 = xor i8 %3, %2
  %7 = zext i8 %6 to i32
  %8 = or i32 %5, %7
  %9 = icmp eq i32 %8, 0
  ret i1 %9
}

define i1 @bcmp_i8(i8 %a0, i8 %b0, i8 %a1, i8 %b1, i8 %a2, i8 %b2) {
; CHECK-LABEL: define i1 @bcmp_i8(
; CHECK-SAME: i8 [[A0:%.*]], i8 [[B0:%.*]], i8 [[A1:%.*]], i8 [[B1:%.*]], i8 [[A2:%.*]], i8 [[B2:%.*]]) {
; CHECK-NEXT:    [[XOR0:%.*]] = xor i8 [[B0]], [[A0]]
; CHECK-NEXT:    [[XOR1:%.*]] = xor i8 [[B1]], [[A1]]
; CHECK-NEXT:    [[XOR2:%.*]] = xor i8 [[B2]], [[A2]]
; CHECK-NEXT:    [[OR0:%.*]] = or i8 [[XOR0]], [[XOR1]]
; CHECK-NEXT:    [[OR1:%.*]] = or i8 [[OR0]], [[XOR2]]
; CHECK-NEXT:    [[R:%.*]] = icmp eq i8 [[OR1]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %xor0 = xor i8 %b0, %a0
  %xor1 = xor i8 %b1, %a1
  %xor2 = xor i8 %b2, %a2
  %or0 = or i8 %xor0, %xor1
  %or1 = or i8 %or0, %xor2
  %r = icmp eq i8 %or1, 0
  ret i1 %r
}

define i1 @bcmp_i16(i16 %a0, i16 %b0, i16 %a1, i16 %b1, i16 %a2, i16 %b2) {
; CHECK-LABEL: define i1 @bcmp_i16(
; CHECK-SAME: i16 [[A0:%.*]], i16 [[B0:%.*]], i16 [[A1:%.*]], i16 [[B1:%.*]], i16 [[A2:%.*]], i16 [[B2:%.*]]) {
; CHECK-NEXT:    [[XOR0:%.*]] = xor i16 [[B0]], [[A0]]
; CHECK-NEXT:    [[XOR1:%.*]] = xor i16 [[B1]], [[A1]]
; CHECK-NEXT:    [[XOR2:%.*]] = xor i16 [[B2]], [[A2]]
; CHECK-NEXT:    [[OR0:%.*]] = or i16 [[XOR0]], [[XOR1]]
; CHECK-NEXT:    [[OR1:%.*]] = or i16 [[OR0]], [[XOR2]]
; CHECK-NEXT:    [[R:%.*]] = icmp eq i16 [[OR1]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %xor0 = xor i16 %b0, %a0
  %xor1 = xor i16 %b1, %a1
  %xor2 = xor i16 %b2, %a2
  %or0 = or i16 %xor0, %xor1
  %or1 = or i16 %or0, %xor2
  %r = icmp eq i16 %or1, 0
  ret i1 %r
}

define i1 @bcmp_i128(i128 %a0, i128 %b0, i128 %a1, i128 %b1, i128 %a2, i128 %b2) {
; CHECK-LABEL: define i1 @bcmp_i128(
; CHECK-SAME: i128 [[A0:%.*]], i128 [[B0:%.*]], i128 [[A1:%.*]], i128 [[B1:%.*]], i128 [[A2:%.*]], i128 [[B2:%.*]]) {
; CHECK-NEXT:    [[XOR0:%.*]] = xor i128 [[B0]], [[A0]]
; CHECK-NEXT:    [[XOR1:%.*]] = xor i128 [[B1]], [[A1]]
; CHECK-NEXT:    [[XOR2:%.*]] = xor i128 [[B2]], [[A2]]
; CHECK-NEXT:    [[OR0:%.*]] = or i128 [[XOR0]], [[XOR1]]
; CHECK-NEXT:    [[OR1:%.*]] = or i128 [[OR0]], [[XOR2]]
; CHECK-NEXT:    [[R:%.*]] = icmp ne i128 [[OR1]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %xor0 = xor i128 %b0, %a0
  %xor1 = xor i128 %b1, %a1
  %xor2 = xor i128 %b2, %a2
  %or0 = or i128 %xor0, %xor1
  %or1 = or i128 %or0, %xor2
  %r = icmp ne i128 %or1, 0
  ret i1 %r
}

define i1 @bcmp_i42(i42 %a0, i42 %b0, i42 %a1, i42 %b1, i42 %a2, i42 %b2) {
; CHECK-LABEL: define i1 @bcmp_i42(
; CHECK-SAME: i42 [[A0:%.*]], i42 [[B0:%.*]], i42 [[A1:%.*]], i42 [[B1:%.*]], i42 [[A2:%.*]], i42 [[B2:%.*]]) {
; CHECK-NEXT:    [[XOR0:%.*]] = xor i42 [[B0]], [[A0]]
; CHECK-NEXT:    [[XOR1:%.*]] = xor i42 [[B1]], [[A1]]
; CHECK-NEXT:    [[XOR2:%.*]] = xor i42 [[B2]], [[A2]]
; CHECK-NEXT:    [[OR0:%.*]] = or i42 [[XOR0]], [[XOR1]]
; CHECK-NEXT:    [[OR1:%.*]] = or i42 [[OR0]], [[XOR2]]
; CHECK-NEXT:    [[R:%.*]] = icmp ne i42 [[OR1]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %xor0 = xor i42 %b0, %a0
  %xor1 = xor i42 %b1, %a1
  %xor2 = xor i42 %b2, %a2
  %or0 = or i42 %xor0, %xor1
  %or1 = or i42 %or0, %xor2
  %r = icmp ne i42 %or1, 0
  ret i1 %r
}
