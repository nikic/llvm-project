; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -S -passes=expand-memcmp -passes=expand-memcmp -memcmp-num-loads-per-block=1 -mtriple=x86_64-unknown-unknown         < %s | FileCheck %s --check-prefix=X64_1LD
; RUN: opt -S -passes=expand-memcmp -memcmp-num-loads-per-block=2 -mtriple=x86_64-unknown-unknown         < %s | FileCheck %s  --check-prefix=X64_2LD


declare signext i32 @memcmp(ptr %src1, ptr %src2, i64 %size)

; Zero-length comparisons should be optimized away.
define i32 @f1(ptr %src1, ptr %src2) {
; X64-LABEL: define i32 @f1(
; X64-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]]) {
; X64-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 0) #[[ATTR0:[0-9]+]]
; X64-NEXT:    ret i32 [[RES]]
;
; X64_1LD-LABEL: define i32 @f1(
; X64_1LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]]) {
; X64_1LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 0) #[[ATTR0:[0-9]+]]
; X64_1LD-NEXT:    ret i32 [[RES]]
;
; X64_2LD-LABEL: define i32 @f1(
; X64_2LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]]) {
; X64_2LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 0) #[[ATTR0:[0-9]+]]
; X64_2LD-NEXT:    ret i32 [[RES]]
;
  %res = call i32 @memcmp(ptr %src1, ptr %src2, i64 0) nobuiltin
  ret i32 %res
}

; Check a case where the result is used as an integer.
define i32 @f2(ptr %src1, ptr %src2) {
; X64-LABEL: define i32 @f2(
; X64-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]]) {
; X64-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 2) #[[ATTR0]]
; X64-NEXT:    ret i32 [[RES]]
;
; X64_1LD-LABEL: define i32 @f2(
; X64_1LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]]) {
; X64_1LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 2) #[[ATTR0]]
; X64_1LD-NEXT:    ret i32 [[RES]]
;
; X64_2LD-LABEL: define i32 @f2(
; X64_2LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]]) {
; X64_2LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 2) #[[ATTR0]]
; X64_2LD-NEXT:    ret i32 [[RES]]
;
  %res = call i32 @memcmp(ptr %src1, ptr %src2, i64 2) nobuiltin
  ret i32 %res
}

; Check a case where the result is tested for equality.
define void @f3(ptr %src1, ptr %src2, ptr %dest) {
; X64-LABEL: define void @f3(
; X64-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 3) #[[ATTR0]]
; X64-NEXT:    [[CMP:%.*]] = icmp eq i32 [[RES]], 0
; X64-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64:       store:
; X64-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64-NEXT:    br label [[EXIT]]
; X64:       exit:
; X64-NEXT:    ret void
;
; X64_1LD-LABEL: define void @f3(
; X64_1LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64_1LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 3) #[[ATTR0]]
; X64_1LD-NEXT:    [[CMP:%.*]] = icmp eq i32 [[RES]], 0
; X64_1LD-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64_1LD:       store:
; X64_1LD-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64_1LD-NEXT:    br label [[EXIT]]
; X64_1LD:       exit:
; X64_1LD-NEXT:    ret void
;
; X64_2LD-LABEL: define void @f3(
; X64_2LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64_2LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 3) #[[ATTR0]]
; X64_2LD-NEXT:    [[CMP:%.*]] = icmp eq i32 [[RES]], 0
; X64_2LD-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64_2LD:       store:
; X64_2LD-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64_2LD-NEXT:    br label [[EXIT]]
; X64_2LD:       exit:
; X64_2LD-NEXT:    ret void
;
  %res = call i32 @memcmp(ptr %src1, ptr %src2, i64 3) nobuiltin
  %cmp = icmp eq i32 %res, 0
  br i1 %cmp, label %exit, label %store

store:
  store i32 0, ptr %dest
  br label %exit

exit:
  ret void
}

; Check a case where the result is tested for inequality.
define void @f4(ptr %src1, ptr %src2, ptr %dest) {
; X64-LABEL: define void @f4(
; X64-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64-NEXT:  entry:
; X64-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 4) #[[ATTR0]]
; X64-NEXT:    [[CMP:%.*]] = icmp ne i32 [[RES]], 0
; X64-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64:       store:
; X64-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64-NEXT:    br label [[EXIT]]
; X64:       exit:
; X64-NEXT:    ret void
;
; X64_1LD-LABEL: define void @f4(
; X64_1LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64_1LD-NEXT:  entry:
; X64_1LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 4) #[[ATTR0]]
; X64_1LD-NEXT:    [[CMP:%.*]] = icmp ne i32 [[RES]], 0
; X64_1LD-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64_1LD:       store:
; X64_1LD-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64_1LD-NEXT:    br label [[EXIT]]
; X64_1LD:       exit:
; X64_1LD-NEXT:    ret void
;
; X64_2LD-LABEL: define void @f4(
; X64_2LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64_2LD-NEXT:  entry:
; X64_2LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 4) #[[ATTR0]]
; X64_2LD-NEXT:    [[CMP:%.*]] = icmp ne i32 [[RES]], 0
; X64_2LD-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64_2LD:       store:
; X64_2LD-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64_2LD-NEXT:    br label [[EXIT]]
; X64_2LD:       exit:
; X64_2LD-NEXT:    ret void
;
entry:
  %res = call i32 @memcmp(ptr %src1, ptr %src2, i64 4) nobuiltin
  %cmp = icmp ne i32 %res, 0
  br i1 %cmp, label %exit, label %store

store:
  store i32 0, ptr %dest
  br label %exit

exit:
  ret void
}

; Check a case where the result is tested via slt.
define void @f5(ptr %src1, ptr %src2, ptr %dest) {
; X64-LABEL: define void @f5(
; X64-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64-NEXT:  entry:
; X64-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 5) #[[ATTR0]]
; X64-NEXT:    [[CMP:%.*]] = icmp slt i32 [[RES]], 0
; X64-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64:       store:
; X64-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64-NEXT:    br label [[EXIT]]
; X64:       exit:
; X64-NEXT:    ret void
;
; X64_1LD-LABEL: define void @f5(
; X64_1LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64_1LD-NEXT:  entry:
; X64_1LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 5) #[[ATTR0]]
; X64_1LD-NEXT:    [[CMP:%.*]] = icmp slt i32 [[RES]], 0
; X64_1LD-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64_1LD:       store:
; X64_1LD-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64_1LD-NEXT:    br label [[EXIT]]
; X64_1LD:       exit:
; X64_1LD-NEXT:    ret void
;
; X64_2LD-LABEL: define void @f5(
; X64_2LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64_2LD-NEXT:  entry:
; X64_2LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 5) #[[ATTR0]]
; X64_2LD-NEXT:    [[CMP:%.*]] = icmp slt i32 [[RES]], 0
; X64_2LD-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64_2LD:       store:
; X64_2LD-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64_2LD-NEXT:    br label [[EXIT]]
; X64_2LD:       exit:
; X64_2LD-NEXT:    ret void
;
entry:
  %res = call i32 @memcmp(ptr %src1, ptr %src2, i64 5) nobuiltin
  %cmp = icmp slt i32 %res, 0
  br i1 %cmp, label %exit, label %store

store:
  store i32 0, ptr %dest
  br label %exit

exit:
  ret void
}

; Check a case where the result is tested for sgt.
define void @f6(ptr %src1, ptr %src2, ptr %dest) {
; X64-LABEL: define void @f6(
; X64-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64-NEXT:  entry:
; X64-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 6) #[[ATTR0]]
; X64-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[RES]], 0
; X64-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64:       store:
; X64-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64-NEXT:    br label [[EXIT]]
; X64:       exit:
; X64-NEXT:    ret void
;
; X64_1LD-LABEL: define void @f6(
; X64_1LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64_1LD-NEXT:  entry:
; X64_1LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 6) #[[ATTR0]]
; X64_1LD-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[RES]], 0
; X64_1LD-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64_1LD:       store:
; X64_1LD-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64_1LD-NEXT:    br label [[EXIT]]
; X64_1LD:       exit:
; X64_1LD-NEXT:    ret void
;
; X64_2LD-LABEL: define void @f6(
; X64_2LD-SAME: ptr [[SRC1:%.*]], ptr [[SRC2:%.*]], ptr [[DEST:%.*]]) {
; X64_2LD-NEXT:  entry:
; X64_2LD-NEXT:    [[RES:%.*]] = call i32 @memcmp(ptr [[SRC1]], ptr [[SRC2]], i64 6) #[[ATTR0]]
; X64_2LD-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[RES]], 0
; X64_2LD-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[STORE:%.*]]
; X64_2LD:       store:
; X64_2LD-NEXT:    store i32 0, ptr [[DEST]], align 4
; X64_2LD-NEXT:    br label [[EXIT]]
; X64_2LD:       exit:
; X64_2LD-NEXT:    ret void
;
entry:
  %res = call i32 @memcmp(ptr %src1, ptr %src2, i64 6) nobuiltin
  %cmp = icmp sgt i32 %res, 0
  br i1 %cmp, label %exit, label %store

store:
  store i32 0, ptr %dest
  br label %exit

exit:
  ret void
}
