; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -simplifycfg < %s | FileCheck %s

declare void @dummy()

define i32 @basic(i32 %x, i32* %p) {
; CHECK-LABEL: @basic(
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[X:%.*]], 2
; CHECK-NEXT:    br i1 [[SWITCH]], label [[BB1:%.*]], label [[BB3:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store i32 0, i32* [[P:%.*]], align 4
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BB1]] ], [ 1, [[BB3]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
  switch i32 %x, label %bb3 [
  i32 0, label %bb1
  i32 1, label %bb2
  ]

bb1:
  store i32 0, i32* %p
  br label %exit

bb2:
  store i32 0, i32* %p
  br label %exit

bb3:
  call void @dummy()
  br label %exit

exit:
  %phi = phi i32 [ 0, %bb1 ], [ 0, %bb2 ], [ 1, %bb3]
  ret i32 %phi
}

; nonnull present in block blocks, keep it.
define i32 @metadata_nonnull_keep(i32 %x, i32** %p1, i32** %p2) {
; CHECK-LABEL: @metadata_nonnull_keep(
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[X:%.*]], 2
; CHECK-NEXT:    br i1 [[SWITCH]], label [[BB1:%.*]], label [[BB3:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[V1:%.*]] = load i32*, i32** [[P1:%.*]], align 4, !nonnull !0
; CHECK-NEXT:    store i32* [[V1]], i32** [[P2:%.*]], align 8
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BB1]] ], [ 1, [[BB3]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
  switch i32 %x, label %bb3 [
  i32 0, label %bb1
  i32 1, label %bb2
  ]

bb1:
  %v1 = load i32*, i32** %p1, align 4, !nonnull !{}
  store i32* %v1, i32** %p2
  br label %exit

bb2:
  %v2 = load i32*, i32** %p1, align 4, !nonnull !{}
  store i32* %v2, i32** %p2
  br label %exit

bb3:
  call void @dummy()
  br label %exit

exit:
  %phi = phi i32 [ 0, %bb1 ], [ 0, %bb2 ], [ 1, %bb3]
  ret i32 %phi
}

; nonnull only present in one of the blocks, drop it.
define i32 @metadata_nonnull_drop(i32 %x, i32** %p1, i32** %p2) {
; CHECK-LABEL: @metadata_nonnull_drop(
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[X:%.*]], 2
; CHECK-NEXT:    br i1 [[SWITCH]], label [[BB1:%.*]], label [[BB3:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[V1:%.*]] = load i32*, i32** [[P1:%.*]], align 4
; CHECK-NEXT:    store i32* [[V1]], i32** [[P2:%.*]], align 8
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BB1]] ], [ 1, [[BB3]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
  switch i32 %x, label %bb3 [
  i32 0, label %bb1
  i32 1, label %bb2
  ]

bb1:
  %v1 = load i32*, i32** %p1, align 4, !nonnull !{}
  store i32* %v1, i32** %p2
  br label %exit

bb2:
  %v2 = load i32*, i32** %p1, align 4
  store i32* %v2, i32** %p2
  br label %exit

bb3:
  call void @dummy()
  br label %exit

exit:
  %phi = phi i32 [ 0, %bb1 ], [ 0, %bb2 ], [ 1, %bb3]
  ret i32 %phi
}

; The union of both range metadatas should be taken.
define i32 @metadata_range(i32 %x, i32* %p1, i32* %p2) {
; CHECK-LABEL: @metadata_range(
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[X:%.*]], 2
; CHECK-NEXT:    br i1 [[SWITCH]], label [[BB1:%.*]], label [[BB3:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[V1:%.*]] = load i32, i32* [[P1:%.*]], align 4, !range !1
; CHECK-NEXT:    store i32 [[V1]], i32* [[P2:%.*]], align 4
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BB1]] ], [ 1, [[BB3]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
  switch i32 %x, label %bb3 [
  i32 0, label %bb1
  i32 1, label %bb2
  ]

bb1:
  %v1 = load i32, i32* %p1, align 4, !range !{i32 0, i32 10}
  store i32 %v1, i32* %p2
  br label %exit

bb2:
  %v2 = load i32, i32* %p1, align 4, !range !{i32 5, i32 15}
  store i32 %v2, i32* %p2
  br label %exit

bb3:
  call void @dummy()
  br label %exit

exit:
  %phi = phi i32 [ 0, %bb1 ], [ 0, %bb2 ], [ 1, %bb3]
  ret i32 %phi
}

; Only the common nuw flag may be preserved.
define i32 @attributes(i32 %x, i32 %y) {
; CHECK-LABEL: @attributes(
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[X:%.*]], 2
; CHECK-NEXT:    br i1 [[SWITCH]], label [[BB1:%.*]], label [[BB3:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[A:%.*]] = add nuw i32 [[Y:%.*]], 1
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[A]], [[BB1]] ], [ 1, [[BB3]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
  switch i32 %x, label %bb3 [
  i32 0, label %bb1
  i32 1, label %bb2
  ]

bb1:
  %a = add nuw nsw i32 %y, 1
  br label %exit

bb2:
  %b = add nuw i32 %y, 1
  br label %exit

bb3:
  call void @dummy()
  br label %exit

exit:
  %phi = phi i32 [ %a, %bb1 ], [ %b, %bb2 ], [ 1, %bb3]
  ret i32 %phi
}

; Don't try to merge with the entry block.
define void @entry_block() {
; CHECK-LABEL: @entry_block(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop

loop:
  br label %loop
}

; Callbr may not have duplicate destinations.
define void @callbr() {
; CHECK-LABEL: @callbr(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    callbr void asm sideeffect "", "X"(i8* blockaddress(@callbr, [[BB1:%.*]]))
; CHECK-NEXT:    to label [[BB2:%.*]] [label %bb1]
; CHECK:       bb1:
; CHECK-NEXT:    ret void
; CHECK:       bb2:
; CHECK-NEXT:    ret void
;
entry:
  callbr void asm sideeffect "", "X"(i8* blockaddress(@callbr, %bb1))
  to label %bb2 [ label %bb1 ]

bb1:
  ret void

bb2:
  ret void
}

; This requires merging bb3,4,5,6 before bb1,2.
define i32 @two_level(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @two_level(
; CHECK-NEXT:    switch i32 [[Z:%.*]], label [[BB7:%.*]] [
; CHECK-NEXT:    i32 0, label [[BB1:%.*]]
; CHECK-NEXT:    i32 1, label [[BB2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       bb1:
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[X:%.*]], 2
; CHECK-NEXT:    br i1 [[SWITCH]], label [[BB3:%.*]], label [[BB7]]
; CHECK:       bb2:
; CHECK-NEXT:    [[SWITCH1:%.*]] = icmp ult i32 [[X]], 2
; CHECK-NEXT:    br i1 [[SWITCH1]], label [[BB3]], label [[BB7]]
; CHECK:       bb3:
; CHECK-NEXT:    [[A:%.*]] = add i32 [[Y:%.*]], 1
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       bb7:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[A]], [[BB3]] ], [ 0, [[BB7]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
  switch i32 %z, label %bb7 [
  i32 0, label %bb1
  i32 1, label %bb2
  ]

bb1:
  switch i32 %x, label %bb7 [
  i32 0, label %bb3
  i32 1, label %bb4
  ]

bb2:
  switch i32 %x, label %bb7 [
  i32 0, label %bb5
  i32 1, label %bb6
  ]

bb3:
  %a = add i32 %y, 1
  br label %exit

bb4:
  %b = add i32 %y, 1
  br label %exit

bb5:
  %c = add i32 %y, 1
  br label %exit

bb6:
  %d = add i32 %y, 1
  br label %exit

bb7:
  call void @dummy()
  br label %exit

exit:
  %phi = phi i32 [ %a, %bb3 ], [ %b, %bb4 ], [ %c, %bb5 ], [ %d, %bb6 ], [ 0, %bb7 ]
  ret i32 %phi
}

; The blocks can be merged if the phi nodes are.
define i32 @phi_merge(i32 %x, i32 %y, i32* %p) {
; CHECK-LABEL: @phi_merge(
; CHECK-NEXT:    switch i32 [[Y:%.*]], label [[SW:%.*]] [
; CHECK-NEXT:    i32 0, label [[IND1:%.*]]
; CHECK-NEXT:    i32 1, label [[IND2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       sw:
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[X:%.*]], 2
; CHECK-NEXT:    br i1 [[SWITCH]], label [[BB1:%.*]], label [[BB3:%.*]]
; CHECK:       ind1:
; CHECK-NEXT:    store i32 0, i32* [[P:%.*]], align 4
; CHECK-NEXT:    br label [[BB1]]
; CHECK:       ind2:
; CHECK-NEXT:    store i32 1, i32* [[P]], align 4
; CHECK-NEXT:    br label [[BB1]]
; CHECK:       bb1:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i32 [ 1, [[IND1]] ], [ 0, [[SW]] ], [ 2, [[IND2]] ]
; CHECK-NEXT:    store i32 [[PHI1]], i32* [[P]], align 4
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BB1]] ], [ 1, [[BB3]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
  switch i32 %y, label %sw [
  i32 0, label %ind1
  i32 1, label %ind2
  ]

sw:
  switch i32 %x, label %bb3 [
  i32 0, label %bb1
  i32 1, label %bb2
  ]

ind1:
  store i32 0, i32* %p
  br label %bb1

ind2:
  store i32 1, i32* %p
  br label %bb2

bb1:
  %phi1 = phi i32 [ 0, %sw ], [ 1, %ind1 ]
  store i32 %phi1, i32* %p
  br label %exit

bb2:
  %phi2 = phi i32 [ 0, %sw ], [ 2, %ind2 ]
  store i32 %phi2, i32* %p
  br label %exit

bb3:
  call void @dummy()
  br label %exit

exit:
  %phi = phi i32 [ 0, %bb1 ], [ 0, %bb2 ], [ 1, %bb3]
  ret i32 %phi
}

; The blocks cannot be merged, because the incoming values for %sw
; are different.
define i32 @phi_merge_different_incoming(i32 %x, i32 %y, i32* %p) {
; CHECK-LABEL: @phi_merge_different_incoming(
; CHECK-NEXT:    switch i32 [[Y:%.*]], label [[SW:%.*]] [
; CHECK-NEXT:    i32 0, label [[IND1:%.*]]
; CHECK-NEXT:    i32 1, label [[IND2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       sw:
; CHECK-NEXT:    switch i32 [[X:%.*]], label [[BB3:%.*]] [
; CHECK-NEXT:    i32 0, label [[BB1:%.*]]
; CHECK-NEXT:    i32 1, label [[BB2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       ind1:
; CHECK-NEXT:    store i32 0, i32* [[P:%.*]], align 4
; CHECK-NEXT:    br label [[BB1]]
; CHECK:       ind2:
; CHECK-NEXT:    store i32 1, i32* [[P]], align 4
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb1:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[SW]] ], [ 1, [[IND1]] ]
; CHECK-NEXT:    store i32 [[PHI1]], i32* [[P]], align 4
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[PHI2:%.*]] = phi i32 [ 3, [[SW]] ], [ 2, [[IND2]] ]
; CHECK-NEXT:    store i32 [[PHI2]], i32* [[P]], align 4
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       bb3:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BB1]] ], [ 0, [[BB2]] ], [ 1, [[BB3]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
  switch i32 %y, label %sw [
  i32 0, label %ind1
  i32 1, label %ind2
  ]

sw:
  switch i32 %x, label %bb3 [
  i32 0, label %bb1
  i32 1, label %bb2
  ]

ind1:
  store i32 0, i32* %p
  br label %bb1

ind2:
  store i32 1, i32* %p
  br label %bb2

bb1:
  %phi1 = phi i32 [ 0, %sw ], [ 1, %ind1 ]
  store i32 %phi1, i32* %p
  br label %exit

bb2:
  %phi2 = phi i32 [ 3, %sw ], [ 2, %ind2 ]
  store i32 %phi2, i32* %p
  br label %exit

bb3:
  call void @dummy()
  br label %exit

exit:
  %phi = phi i32 [ 0, %bb1 ], [ 0, %bb2 ], [ 1, %bb3]
  ret i32 %phi
}

; Cannot merge loop.entry and loop.latch, because loop.entry dominates
; loop.latch dominates a use of the loop.entry phi.
define i32 @phi_merge_loop_header(i1 %c1, i1 %c2, i1 %c3, i32* %p) {
; CHECK-LABEL: @phi_merge_loop_header(
; CHECK-NEXT:    br i1 [[C1:%.*]], label [[ENTRY_THEN1:%.*]], label [[ENTRY_THEN2:%.*]]
; CHECK:       entry.then1:
; CHECK-NEXT:    store i32 0, i32* [[P:%.*]], align 4
; CHECK-NEXT:    br label [[LOOP_ENTRY:%.*]]
; CHECK:       entry.then2:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[LOOP_ENTRY]]
; CHECK:       loop.entry:
; CHECK-NEXT:    [[PHI0:%.*]] = phi i32 [ 0, [[ENTRY_THEN1]] ], [ 1, [[ENTRY_THEN2]] ]
; CHECK-NEXT:    br label [[LOOP_COND:%.*]]
; CHECK:       loop.cond:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i32 [ [[PHI0]], [[LOOP_ENTRY]] ], [ [[PHI2:%.*]], [[LOOP_LATCH:%.*]] ]
; CHECK-NEXT:    br i1 [[C2:%.*]], label [[LOOP_IF:%.*]], label [[LOOP_EXIT:%.*]]
; CHECK:       loop.if:
; CHECK-NEXT:    br i1 [[C3:%.*]], label [[LOOP_THEN1:%.*]], label [[LOOP_THEN2:%.*]]
; CHECK:       loop.then1:
; CHECK-NEXT:    store i32 0, i32* [[P]], align 4
; CHECK-NEXT:    br label [[LOOP_LATCH]]
; CHECK:       loop.then2:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[LOOP_LATCH]]
; CHECK:       loop.latch:
; CHECK-NEXT:    [[PHI2]] = phi i32 [ 2, [[LOOP_THEN1]] ], [ 3, [[LOOP_THEN2]] ]
; CHECK-NEXT:    br label [[LOOP_COND]]
; CHECK:       loop.exit:
; CHECK-NEXT:    ret i32 [[PHI0]]
;
  br i1 %c1, label %entry.then1, label %entry.then2

entry.then1:
  store i32 0, i32* %p
  br label %loop.entry

entry.then2:
  call void @dummy()
  br label %loop.entry

loop.entry:
  %phi0 = phi i32 [ 0, %entry.then1 ], [ 1, %entry.then2 ]
  br label %loop.cond

loop.cond:
  %phi1 = phi i32 [ %phi0, %loop.entry ], [ %phi2, %loop.latch ]
  br i1 %c2, label %loop.if, label %loop.exit

loop.if:
  br i1 %c3, label %loop.then1, label %loop.then2

loop.then1:
  store i32 0, i32* %p
  br label %loop.latch

loop.then2:
  call void @dummy()
  br label %loop.latch

loop.latch:
  %phi2 = phi i32 [ 2, %loop.then1 ], [ 3, %loop.then2 ]
  br label %loop.cond

loop.exit:
  ret i32 %phi0
}

; CHECK: !1 = !{i32 0, i32 15}
