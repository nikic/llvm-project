; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S --passes='simplifycfg<hoist-common-insts>' %s | FileCheck %s
; RUN: opt -S --passes='simplifycfg<hoist-common-insts>' -simplifycfg-hoist-common-skip-limit=0 %s | FileCheck %s --check-prefix=LIMIT

;; Check that the two loads are hoisted to the common predecessor, skipping
;; over the add/sub instructions.
;; Second run line, check that only one of the loads is hoisted, due to
;; the skip limit.

define i32 @f(ptr nocapture noundef %d, ptr nocapture noundef readonly %m, ptr nocapture noundef readonly %b) {
; CHECK-LABEL: @f(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load i16, ptr [[D:%.*]], align 2
; CHECK-NEXT:    [[CONV:%.*]] = sext i16 [[TMP0]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i16 [[TMP0]], 0
; CHECK-NEXT:    [[TMP1:%.*]] = load i16, ptr [[B:%.*]], align 2
; CHECK-NEXT:    [[CONV2:%.*]] = zext i16 [[TMP1]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = load i16, ptr [[M:%.*]], align 2
; CHECK-NEXT:    [[CONV4:%.*]] = zext i16 [[TMP2]] to i32
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[CONV2]], [[CONV]]
; CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[ADD]], [[CONV4]]
; CHECK-NEXT:    [[TMP3:%.*]] = lshr i32 [[MUL]], 16
; CHECK-NEXT:    [[CONV5:%.*]] = trunc i32 [[TMP3]] to i16
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[CONV2]], [[CONV]]
; CHECK-NEXT:    [[MUL9:%.*]] = mul nsw i32 [[SUB]], [[CONV4]]
; CHECK-NEXT:    [[TMP4:%.*]] = lshr i32 [[MUL9]], 16
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP4]] to i16
; CHECK-NEXT:    [[CONV12:%.*]] = sub i16 0, [[TMP5]]
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i16 [ [[CONV12]], [[IF_ELSE]] ], [ [[CONV5]], [[IF_THEN]] ]
; CHECK-NEXT:    store i16 [[STOREMERGE]], ptr [[D]], align 2
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i16 [[STOREMERGE]], 0
; CHECK-NEXT:    [[LNOT_EXT:%.*]] = zext i1 [[TOBOOL]] to i32
; CHECK-NEXT:    ret i32 [[LNOT_EXT]]
;
; LIMIT-LABEL: @f(
; LIMIT-NEXT:  entry:
; LIMIT-NEXT:    [[TMP0:%.*]] = load i16, ptr [[D:%.*]], align 2
; LIMIT-NEXT:    [[CONV:%.*]] = sext i16 [[TMP0]] to i32
; LIMIT-NEXT:    [[CMP:%.*]] = icmp sgt i16 [[TMP0]], 0
; LIMIT-NEXT:    [[TMP1:%.*]] = load i16, ptr [[B:%.*]], align 2
; LIMIT-NEXT:    [[CONV2:%.*]] = zext i16 [[TMP1]] to i32
; LIMIT-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; LIMIT:       if.then:
; LIMIT-NEXT:    [[ADD:%.*]] = add nsw i32 [[CONV2]], [[CONV]]
; LIMIT-NEXT:    [[TMP2:%.*]] = load i16, ptr [[M:%.*]], align 2
; LIMIT-NEXT:    [[CONV4:%.*]] = zext i16 [[TMP2]] to i32
; LIMIT-NEXT:    [[MUL:%.*]] = mul nsw i32 [[ADD]], [[CONV4]]
; LIMIT-NEXT:    [[TMP3:%.*]] = lshr i32 [[MUL]], 16
; LIMIT-NEXT:    [[CONV5:%.*]] = trunc i32 [[TMP3]] to i16
; LIMIT-NEXT:    br label [[IF_END:%.*]]
; LIMIT:       if.else:
; LIMIT-NEXT:    [[SUB:%.*]] = sub nsw i32 [[CONV2]], [[CONV]]
; LIMIT-NEXT:    [[TMP4:%.*]] = load i16, ptr [[M]], align 2
; LIMIT-NEXT:    [[CONV8:%.*]] = zext i16 [[TMP4]] to i32
; LIMIT-NEXT:    [[MUL9:%.*]] = mul nsw i32 [[SUB]], [[CONV8]]
; LIMIT-NEXT:    [[TMP5:%.*]] = lshr i32 [[MUL9]], 16
; LIMIT-NEXT:    [[TMP6:%.*]] = trunc i32 [[TMP5]] to i16
; LIMIT-NEXT:    [[CONV12:%.*]] = sub i16 0, [[TMP6]]
; LIMIT-NEXT:    br label [[IF_END]]
; LIMIT:       if.end:
; LIMIT-NEXT:    [[STOREMERGE:%.*]] = phi i16 [ [[CONV12]], [[IF_ELSE]] ], [ [[CONV5]], [[IF_THEN]] ]
; LIMIT-NEXT:    store i16 [[STOREMERGE]], ptr [[D]], align 2
; LIMIT-NEXT:    [[TOBOOL:%.*]] = icmp ne i16 [[STOREMERGE]], 0
; LIMIT-NEXT:    [[LNOT_EXT:%.*]] = zext i1 [[TOBOOL]] to i32
; LIMIT-NEXT:    ret i32 [[LNOT_EXT]]
;

entry:
  %0 = load i16, ptr %d, align 2
  %conv = sext i16 %0 to i32
  %cmp = icmp sgt i16 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i16, ptr %b, align 2
  %conv2 = zext i16 %1 to i32
  %add = add nsw i32 %conv2, %conv
  %2 = load i16, ptr %m, align 2
  %conv4 = zext i16 %2 to i32
  %mul = mul nsw i32 %add, %conv4
  %3 = lshr i32 %mul, 16
  %conv5 = trunc i32 %3 to i16
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load i16, ptr %b, align 2
  %conv6 = zext i16 %4 to i32
  %sub = sub nsw i32 %conv6, %conv
  %5 = load i16, ptr %m, align 2
  %conv8 = zext i16 %5 to i32
  %mul9 = mul nsw i32 %sub, %conv8
  %6 = lshr i32 %mul9, 16
  %7 = trunc i32 %6 to i16
  %conv12 = sub i16 0, %7
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %storemerge = phi i16 [ %conv12, %if.else ], [ %conv5, %if.then ]
  store i16 %storemerge, ptr %d, align 2
  %tobool = icmp ne i16 %storemerge, 0
  %lnot.ext = zext i1 %tobool to i32
  ret i32 %lnot.ext
}
