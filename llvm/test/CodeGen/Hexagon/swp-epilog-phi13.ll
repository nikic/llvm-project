; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -march=hexagon -hexagon-initial-cfg-cleanup=0 -pipeliner-experimental-cg=true < %s | FileCheck %s

; Test epilogue generation when reading loop-carried dependency in stage 1 from
; stage 0. Make sure the illegal phi the expender creates gets cleaned up
; correctly during peeling

; Function Attrs: nounwind
define i32* @f0(i16* nocapture readonly %a0, i32 %a1, i32 %a2, i32 %a3,  i16* %b) #0 {
; CHECK-LABEL: f0:
; CHECK:       // %bb.0: // %b0
; CHECK-NEXT:    {
; CHECK-NEXT:     r0 = #0
; CHECK-NEXT:     if (p0) jumpr r31
; CHECK-NEXT:    }
; CHECK-NEXT:  .LBB0_1: // %b1
; CHECK-NEXT:    {
; CHECK-NEXT:     r3 = asl(r2,#1)
; CHECK-NEXT:     r7 = add(r1,#-2)
; CHECK-NEXT:     r2 = #0
; CHECK-NEXT:     r5 = memh(r4+#0)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     r6 = r5
; CHECK-NEXT:     r0 = add(r2,#8)
; CHECK-NEXT:     p0 = cmp.gtu(r1,#1)
; CHECK-NEXT:     r8 = add(r4,r3)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     r5 = mpy(r5.l,r5.l)
; CHECK-NEXT:     r6 += mpy(r0.l,r0.l):sat
; CHECK-NEXT:     memw(r2+#0) = r6.new
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     if (!p0) jump:nt .LBB0_5
; CHECK-NEXT:    }
; CHECK-NEXT:  // %bb.2: // %b2
; CHECK-NEXT:    {
; CHECK-NEXT:     r4 = mpy(r5.l,r5.l)
; CHECK-NEXT:     p0 = cmp.gtu(r1,#2)
; CHECK-NEXT:     r1 = add(r2,#8)
; CHECK-NEXT:     r9 = memh(r8+#0)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     r5 = r9
; CHECK-NEXT:     r8 = add(r8,r3)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     r5 += mpy(r0.l,r0.l):sat
; CHECK-NEXT:     memw(r0+#0) = r5.new
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     loop0(.LBB0_3,r7)
; CHECK-NEXT:     r5 = mpy(r9.l,r9.l)
; CHECK-NEXT:     r7:6 = combine(#0,#0)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     if (!p0) jump:nt .LBB0_4
; CHECK-NEXT:    }
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .Ltmp0: // Block address taken
; CHECK-NEXT:  .LBB0_3: // %b2
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    {
; CHECK-NEXT:     r7 = r2
; CHECK-NEXT:     r2 = r0
; CHECK-NEXT:     r0 = r1
; CHECK-NEXT:     r9 = memh(r8+#0)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     r1 = mpy(r4.l,r4.l)
; CHECK-NEXT:     r4 = mpy(r5.l,r5.l)
; CHECK-NEXT:     r6 = r7
; CHECK-NEXT:     memw(r6+#8) = r1.new
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     r5 = mpy(r9.l,r9.l)
; CHECK-NEXT:     r9 += mpy(r0.l,r0.l):sat
; CHECK-NEXT:     r1 = add(r2,#8)
; CHECK-NEXT:     r8 = add(r8,r3)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     nop
; CHECK-NEXT:     memw(r0+#0) = r9
; CHECK-NEXT:    } :endloop0
; CHECK-NEXT:  .LBB0_4: // %b2
; CHECK-NEXT:    {
; CHECK-NEXT:     r1 = mpy(r4.l,r4.l)
; CHECK-NEXT:     r0 = r1
; CHECK-NEXT:     memw(r7+#8) = r1.new
; CHECK-NEXT:    }
; CHECK-NEXT:  .LBB0_5: // %b2
; CHECK-NEXT:    {
; CHECK-NEXT:     r1 = mpy(r5.l,r5.l)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     r1 = mpy(r1.l,r1.l)
; CHECK-NEXT:     jumpr r31
; CHECK-NEXT:     memw(r2+#8) = r1.new
; CHECK-NEXT:    }
b0:
  br i1 undef, label %b1, label %b3

b1:                                               ; preds = %b0
  br label %b2

b2:                                               ; preds = %b2, %b1
  %v1 = phi i16* [ %a0, %b1 ], [ %v2, %b2 ]
  %v2 = phi i16* [ undef, %b1 ], [ %v15, %b2 ]
  %v3 = phi i32* [ null, %b1 ], [ %v4, %b2 ]
  %v4 = phi i32* [ null, %b1 ], [ %v14, %b2 ]
  %v5 = phi i32 [ 0, %b1 ], [ %v13, %b2 ]
  %v6 = phi i16* [ undef, %b1 ], [ %v12, %b2 ]
  %a = mul i32 %v5, %a2
  %add = getelementptr inbounds i16, i16* %b, i32 %a
  %v7 = load i16, i16* %add, align 2
  %v8 = sext i16 %v7 to i32
  %v9 = call i32 @llvm.hexagon.M2.mpy.ll.s0(i32 %v8, i32 %v8) #2
  %v92 = call i32 @llvm.hexagon.M2.mpy.ll.s0(i32 %v9, i32 %v9) #2
  %v93 = call i32 @llvm.hexagon.M2.mpy.ll.s0(i32 %v92, i32 %v92) #2
  %v11 = call i32 @llvm.hexagon.M2.mpy.acc.sat.ll.s0(i32 %v8, i32 undef, i32 undef) #2
  store i32 %v11, i32* %v4, align 4
  %v12 = getelementptr inbounds i16, i16* %v6, i32 -1
  %v13 = add i32 %v5, 1
  %v14 = getelementptr inbounds i32, i32* %v3, i32 2
  store i32 %v93, i32* %v14, align 4
  %v15 = getelementptr inbounds i16, i16* %v1, i32 2
  %v16 = icmp slt i32 %v13, %a1
  br i1 %v16, label %b2, label %b3

b3:                                               ; preds = %b2, %b0
  %out = phi i32* [ null, %b0 ], [ %v14, %b2 ]
  ret i32* %out
}

; Function Attrs: nounwind readnone
declare i32 @llvm.hexagon.M2.mpy.ll.s0(i32, i32) #1

; Function Attrs: nounwind readnone
declare i32 @llvm.hexagon.M2.mpy.acc.sat.ll.s0(i32, i32, i32) #1

attributes #0 = { nounwind "target-cpu"="hexagonv60" }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
